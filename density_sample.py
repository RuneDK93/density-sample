from sklearn.neighbors import NearestNeighbors
import numpy as np

def density_sample(X,size=0.1,n_neighbours=100,power=1.5,replace=False,random_state=None):
    '''
    Description
    ===========
    The function returns a balanced coverage sample though density weighted random sampling of input data X.
    The sample uses inverse data density weights to generate a sample which 'covers' the input space.
    If a point is in a low-density area, the probability of drawing the point is large,
    whereas if a point is in a high-density area the probability of drawing the point is low.
    
    The sampling weights are generated by computing the mean distance to the nearest neighbours.
    The distances are then scaled to sum to 1 to generate sampling probabilities.
    
    
    Parameters
    ==========
    X -------------> numpy array
        Data matrix with dimension (n x p)
        n = number of observations
        p = number of features
        
    size ----------> float, min=0, max=1, default=0.1
        The sample size indicated by a fraction the original data X. 
        
    n_neighbours --> int, min=1, max=n-1, default=100
        The number of neigbours to consider for the sampling weights.

    power ---------> float, min=-inf, max=inf, default=1.5
        The power of the sample weights. 
        Controls how much to increase sampling probablity with inverse density.
        With positive power the sampling prefers low-density observations
        With negative power the sampling prefers high-density observations
        I.e:
        High power gives more low density observations
        Low power gives less low density observations
        At power = 0 the sampling reduces to simple random sampling with uniform sampling probability. 

    replace --------> bool, default=False 
        Wether to use replacement for the sampling.
        
    random_state ---> int, RandomState instance or None, default=None
        Controls the random seed.
        Pass an int for reproducible output across multiple function calls.


    Returns
    =======
    X_sample -------> numpy array
        The sampled observations
        
    index_sample ---> numpy array
        The index in X of the sampled observations
    '''
    
    # Setting random state
    np.random.seed(random_state)
    
    # Finding nearest neighbours for the data
    knn = NearestNeighbors(n_neighbors=n_neighbours+1) # +1 since first neighbour is the observation itself.
    knn.fit(X)
    index = np.asarray(knn.kneighbors(X, return_distance=True))[:,:,1:]  # Not using the observation itself.
    
    # Finding the mean distance to the nearest neighbours
    mean_nn_distance = np.mean(index[0,:,:],axis=1)**power # Choose higher power to force more low-density observations
    
    # Using the distance weights as probabilities and making them sum to 1
    # The proabability is directly proportional to the mean of the distances to the nearest neighbours
    sampling_prob=mean_nn_distance/np.sum(mean_nn_distance)

    # Find weighted random sample of original data using the sample size and generated sampling weights
    arr = np.arange(X.shape[0])
    index_density = np.random.choice(arr, size=int(X.shape[0]*(size)), replace=replace,p=sampling_prob)  

    # The generated sample
    X_sample_density = X[index_density]

    return X_sample_density, index_density